# -*- coding: utf-8 -*-
"""Concatenado.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OY-BeI6yJqqFkBwtDY0uiuLB9HdDfGwA
"""

from __future__ import annotations
import re
from pathlib import Path
import shutil
from pathlib import Path

# Config
INPUT_DIR = Path("/content/corpus")
OUT_DIR   = Path("/content/concat")
OUT_DIR.mkdir(parents=True, exist_ok=True)

# Helpers
# =========================
def read_nonempty_lines(path: Path) -> list[str]:
    """Lee un .txt y regresa líneas no vacías (trim)."""
    lines = path.read_text(encoding="utf-8", errors="ignore").splitlines()
    cleaned = []
    for ln in lines:
        s = ln.strip()
        if s:
            cleaned.append(s)
    return cleaned

def find_sushi0_file(files: list[Path]) -> Path:
    """
    Encuentra sushi0
    """
    candidates = []
    for p in files:
        stem = p.stem.lower()
        stem = stem.replace("-", "_").replace(" ", "_")
        if stem in {"sushi0", "sushi_0", "s0"}:
            candidates.append(p)
    if len(candidates) == 1:
        return candidates[0]
    if len(candidates) == 0:
        raise FileNotFoundError("No sushi0")
    raise RuntimeError(f"varios sushi0: {[c.name for c in candidates]}")

def short_code(stem: str) -> str:
    """
    nombres:
      sushi(0) -> s0
      sushi_high(i) -> h(i)
      sushi_low(j)  -> l(j)
      NoSushi(k)    -> no(k)
      sushi_nopa(n) -> nopa (n)
    """
    s = stem.lower().replace("-", "_").replace(" ", "_")

    # sushi0
    if s in {"sushi0", "sushi_0", "s0"}:
        return "s0"

    # sushi_high<i>
    m = re.fullmatch(r"sushi_?high(\d+)", s) or re.fullmatch(r"high(\d+)", s)
    if m:
        return f"hi{m.group(1)}"

    # sushi_low<j>
    m = re.fullmatch(r"sushi_?low(\d+)", s) or re.fullmatch(r"low(\d+)", s)
    if m:
        return f"l{m.group(1)}"

    # NoSushi<k>
    m = re.fullmatch(r"nosushi(\d+)", s) or re.fullmatch(r"no_?sushi(\d+)", s)
    if m:
        return f"no{m.group(1)}"  # <- "nok" como lo pediste (no + k)

    # sushi_nopan o sushi_nopan<id>
    m = re.fullmatch(r"sushi_?nopa(\d+)", s) or re.fullmatch(r"nopa(\d+)", s)
    if m:
        return f"nopan{m.group(1)}"
    if s in {"sushi_nopa", "nopa"}:
        return "nopa"

    return re.sub(r"[^a-z0-9]+", "_", s).strip("_")

def write_pair(out_path: Path, lines_a: list[str], lines_b: list[str]) -> None:
    """
    Escribe A y luego B empezando en la línea siguiente.
    Ambos ya vienen sin líneas vacías.
    """
    with out_path.open("w", encoding="utf-8") as f:
        if lines_a:
            f.write("\n".join(lines_a))
        f.write("\n")  # el segundo archivo empieza en la siguiente línea
        if lines_b:
            f.write("\n".join(lines_b))
        f.write("\n")  # newline final estándar

# Main

files = sorted(INPUT_DIR.glob("*.txt"))
if not files:
    raise FileNotFoundError(f"No hay .txt en {INPUT_DIR}")

s0_path = find_sushi0_file(files)
s0_lines = read_nonempty_lines(s0_path)

written = 0
for p in files:
    code = short_code(p.stem)
    out_name = f"s0_{code}.txt"
    out_path = OUT_DIR / out_name

    other_lines = read_nonempty_lines(p)
    write_pair(out_path, s0_lines, other_lines)
    written += 1

print(f" {written} en {OUT_DIR}")

# archivos en zip
CONCAT_DIR = Path("/content/concat")
ZIP_PATH   = Path("/content/concat_sushi_pairs.zip")

if ZIP_PATH.exists():
    ZIP_PATH.unlink()

shutil.make_archive(
    base_name=ZIP_PATH.with_suffix(""),
    format="zip",
    root_dir=CONCAT_DIR
)

print(f"ZIP creado en: {ZIP_PATH}")